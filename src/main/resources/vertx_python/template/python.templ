@comment{"Generate a Python class"}
@comment{"======================="}

@code{
	def requiresTypeCheck(methods) {
		for (method : methods) {
			for (param : method.params) {
				if ([CLASS_PRIMITIVE, CLASS_BOXED_PRIMITIVE, CLASS_STRING, CLASS_JSON_ARRAY, CLASS_JSON_OBJECT, CLASS_HANDLER, CLASS_DATA_OBJECT].contains(param.type.kind)) {
					return true;
				}
			}
		}
		return false;
	}
}

@code{
	def getAllParamNames(methods) {
		paramNames = [];
		for (method : methods) {
			for (param : method.params) {
				if (!paramNames.contains(param.name)) {
					paramNames.add(param.name);
				}
			}
		}
		return paramNames;
	}
}

@code{
	def getParamNames(method) {
		paramNames = [];
		for (param : method.params) {
			paramNames.add(param.name);
		}
		return paramNames;
	}
}

@code{
	def convertName(name) {
		reserved = ['if', 'elif', 'else', 'from', 'in', 'int', 'bool', 'long', 'bytes', 'str', 'unicode', 'not', 'and', 'or', 'as', 'try', 'except', 'raise', 'return', 'lambda', 'finally', 'continue', 'for', 'while', 'yield', 'pass', 'with', 'assert', 'break', 'class', 'def', 'exec', 'del', 'import'];
		return reserved.contains(name) ? helper.convertCamelCaseToUnderscores('_' + name) : helper.convertCamelCaseToUnderscores(name);
	}
}

@declare{'genMethodCall'}
@if{static}util.jvm.@{ifacePackageName}.@{ifaceSimpleName}@else{}self.j@{ifaceName}@end{}.@{method.name}(
	@foreach{param: method.params}
		@code{argName=convertName(param.name);}
		@includeNamed{'convParam'}
	@end{", "})
@end{}

@comment{"Generate the code that converts a parameter from Python to Java to call a Java API method"}
@comment{"============================================================================================="}

@declare{'convParam'}
	@code{paramName = overloaded ? argName : param.name;}
	@if{param.type.kind == CLASS_HANDLER}
		@if{param.type.args[0].kind == CLASS_ASYNC_RESULT}
			@if{param.type.args[0].args[0].raw != null}
				Async@{param.type.args[0].args[0].raw.simpleName}Handler(@{convertName(paramName)})
			@else{}
				Async@{param.type.args[0].args[0].name}Handler(@{convertName(paramName)})
			@end{}
		@else{}
			@if{param.type.args[0].raw != null}
				@{param.type.args[0].raw.simpleName}Handler(@{convertName(paramName)})
			@else{}
				@{param.type.args[0].name}Handler(@{convertName(paramName)})
			@end{}
		@end{}
	@else{param.type.kind == CLASS_JSON_OBJECT}
		util.dict_to_json(@{convertName(paramName)})
	@else{param.type.kind == CLASS_JSON_ARRAY}
		util.list_to_json(@{convertName(paramName)})
	@else{param.dataObject}
		@{param.type.simpleName}(util.dict_to_json(@{convertName(paramName)})) if @{convertName(paramName)} is not None else None
	@else{param.type.name == 'char' || param.type.name == 'java.lang.Character'}
		util.convert_char(@{convertName(paramName)})
	@else{param.type.name == 'long' || param.type.name == 'java.lang.Long'}
		util.convert_long_to_java(@{convertName(paramName)})
	@else{param.type.name == 'byte' || param.type.name == 'java.lang.Byte'}
		util.convert_byte_to_java(@{convertName(paramName)})
	@else{param.type.name == 'short' || param.type.name == 'java.lang.Short'}
		util.convert_short_to_java(@{convertName(paramName)})
	@else{param.type.name == 'float' || param.type.name == 'java.lang.Float'}
		util.convert_float_to_java(@{convertName(paramName)})
	@else{param.type.name == 'double' || param.type.name == 'java.lang.Double'}
		util.convert_double_to_java(@{convertName(paramName)})
	@else{param.type.kind == CLASS_LIST}
		@if{param.type.args[0].name == 'char' || param.type.args[0].name == 'java.lang.Character'}
			util.convert_char(@{convertName(paramName)})
		@else{param.type.args[0].name == 'long' || param.type.args[0].name == 'java.lang.Long'}
			util.convert_long_list_to_java(@{convertName(paramName)})
		@else{param.type.args[0].name == 'byte' || param.type.args[0].name == 'java.lang.Byte'}
			util.convert_byte_list_to_java(@{convertName(paramName)})
		@else{param.type.args[0].name == 'short' || param.type.args[0].name == 'java.lang.Short'}
			util.convert_short_list_to_java(@{convertName(paramName)})
		@else{param.type.args[0].name == 'float' || param.type.args[0].name == 'java.lang.Float'}
			util.convert_float_list_to_java(@{convertName(paramName)})
		@else{param.type.args[0].name == 'double' || param.type.args[0].name == 'java.lang.Double'}
			util.convert_double_list_to_java(@{convertName(paramName)})
		@else{}
			util.python_to_java(@{convertName(paramName)})
		@end{}
	@else{param.type.kind == CLASS_OBJECT}
		util.python_to_java(@{convertName(paramName)})
	@else{param.type.kind.basic || param.type.name.equals("java.lang.Void")}
		@{convertName(paramName)}
	@else{}
		@{convertName(paramName)}._jdel()
	@end{}
@end{}

@declare{'resultVal'}
result
@end{}

@declare{'arVal'}
result.result()
@end{}

@comment{"Generate the code that converts a Java return to the corresponding Python value"}
@comment{"This is also used for converting values returned from Java API via handlers"}
@comment{"==================================================================================="}

@declare{'convReturn'}
	@if{returnType.kind == CLASS_LIST || returnType.kind == CLASS_SET}
		@code{elementType=returnType.args[0]}
		@if{elementType.kind == CLASS_JSON_OBJECT}
			util.list_obj_to_python(@includeNamed{templ}, dict)
		@else{elementType.kind == CLASS_JSON_ARRAY}
			util.list_obj_to_python(@includeNamed{templ}, list)
		@else{elementType.kind == CLASS_API}
			util.list_obj_to_python(@includeNamed{templ}, @{elementType.raw.simpleName})
		@else{}
			@includeNamed{templ}
		@end{}
	@else{returnType.kind == CLASS_JSON_OBJECT || returnType.kind == CLASS_JSON_ARRAY}
		util.java_to_python(@includeNamed{templ})
	@else{returnType.kind.basic || returnType.name.equals('void')}
		@includeNamed{templ}
	@else{returnType.kind == CLASS_DATA_OBJECT}
		util.data_object_to_json(@includeNamed{templ})
	@else{returnType.kind == CLASS_API}
		@if{returnType.raw != null}
			@if{returnType.raw.simpleName.equals("Throwable")}
				util.java_to_python(@includeNamed{templ})
			@else{}
				@{returnType.raw.simpleName}(@includeNamed{templ})
			@end{}
		@else{}
			util.java_to_python(@includeNamed{templ})
		@end{}
	@else{}
		@comment{'This will probably happen if the return type is generic'}
		util.java_to_python(@includeNamed{templ})
	@end{}
@end{}

@comment{"Generate a Python condition"}
@comment{"==========================="}

@declare{'genCondition'}
	@code{methodParamNames = getParamNames(method)}
	@if{paramNames.size() > methodParamNames.size()}
		@code{missingParamNames = []}
		@foreach{paramName: paramNames}
			@if{!methodParamNames.contains(paramName)}
				@code{missingParamNames.add(paramName)}
			@end{}
		@end{}
		@foreach{paramName: missingParamNames}
			@if{optionsParam != null && optionsParam.name == paramName}
				len(@{convertName(paramName)}) == 0
			@else{}
				@{convertName(paramName)} is None
			@end{}
		@end{" and "}
		 and 
	@end{}
	@foreach{param: method.params}
		@if{param.type.kind == CLASS_PRIMITIVE || param.type.kind == CLASS_BOXED_PRIMITIVE}
			@if{param.type.name == 'long' || param.type.name == 'java.lang.Long' ||
				param.type.name == 'int'  || param.type.name == 'java.lang.Integer' ||
				param.type.name == 'short' || param.type.name == 'java.lang.Short'}
				@{convertName(param.name)} is not None and isinstance(@{convertName(param.name)}, int)
			@else{param.type.name == 'float' || param.type.name == 'java.lang.Float' ||
				param.type.name == 'double' || param.type.name == 'java.lang.Double'}
				@{convertName(param.name)} is not None and isinstance(@{convertName(param.name)}, float)
			@else{param.type.name == 'byte' || param.type.name == 'java.lang.Byte'}
				@{convertName(param.name)} is not None and isinstance(@{convertName(param.name)}, int)
			@else{param.type.name == 'boolean' || param.type.name == 'java.lang.Boolean'}
				@{convertName(param.name)} is not None and isinstance(@{convertName(param.name)}, bool)
			@else{param.type.name == 'char' || param.type.name == 'java.lang.Character'}
				@{convertName(param.name)} is not None and isinstance(@{convertName(param.name)}, (basestring, int))
			@end{}
		@else{param.type.kind == CLASS_STRING}
			@{convertName(param.name)} is not None and isinstance(@{convertName(param.name)}, basestring)
		@else{param.type.kind == CLASS_JSON_OBJECT}
	    	@{convertName(param.name)} is not None and isinstance(@{convertName(param.name)}, dict)
		@else{param.type.kind == CLASS_JSON_ARRAY}
			@{convertName(param.name)} is not None and isinstance(@{convertName(param.name)}, (list, tuple))
		@else{param.type.kind == CLASS_HANDLER}
			@{convertName(param.name)} is not None and callable(@{convertName(param.name)})
		@else{param.type.kind == CLASS_DATA_OBJECT}
			True
			@comment{"len(@{convertName(param.name)}) > 0"}
		@else{}
			@comment{"This could possibly be smarter and do an isinstance check sometimes (not always, though)"}
			@{convertName(param.name)} is not None
		@end{}
	@end{" and "}
@end{}

@comment{"Generate a Python Method"}
@comment{"========================"}

@declare{'genMethod'}
	@code{methodList = methodsByName.get(methodName); overloaded = methodList.size() > 1; method = methodList.get(0);}

	@code{requiredParams = []; optionalParams = []; optionsParam = null; paramNames = []; cnt = 0;}
	@foreach{method: methodList}
		@if{cnt == 0}
			@foreach{param: method.params}
				@if{param.type.kind == CLASS_DATA_OBJECT}
					@code{optionsParam = param}
				@end{}
				@code{requiredParams.add(param.name);}
			@end{}
			@code{cnt++}
		@else{}
			@code{newRequiredParams = []}
			@foreach{param: method.params}
				@if{!paramNames.contains(param.name)}@code{paramNames.add(param.name)}@end{}
				@if{param.type.kind == CLASS_DATA_OBJECT}
					@code{optionsParam = param}
				@end{}
				@if{requiredParams.contains(param.name)}
					@code{newRequiredParams.add(param.name)}
				@else{!optionalParams.contains(param.name)}
					@code{optionalParams.add(param.name)}
				@end{}
			@end{}
			@code{requiredParams = newRequiredParams}
		@end{}
	@end{}

	@code{childMethods = []}
	@foreach{method: methodList}
		@code{base = true; methodParamNames = getParamNames(method)}
		@foreach{methodParamName : methodParamNames}
			@if{!requiredParams.contains(methodParamName)}
				@code{base = false}
			@end{}
		@end{}
		@if{!base}@code{childMethods.add(method)}@end{}
	@end{}

	@code{baseMethod = null}
	@foreach{method: methodList}
		@code{base = true; methodParamNames = getParamNames(method)}
		@foreach{methodParamName : methodParamNames}
			@if{!requiredParams.contains(methodParamName)}
				@code{base = false}
			@end{}
		@end{}
		@if{base}@code{baseMethod = method}@end{}
	@end{}

	@if{baseMethod != null && static == method.staticMethod}
		@if{static}@{ind}@@classmethod\n@end{}
		@{ind}def @{convertName(methodName)}(self
		@foreach{param : requiredParams}
			@if{optionsParam == null || param != optionsParam.name}
				, @{convertName(param)}
			@end{}
		@end{}
		@foreach{param: optionalParams}
			@if{optionsParam == null || param != optionsParam.name}
				, @{convertName(param)}=None
			@end{}
		@end{}
		@if{optionsParam != null}
			, **@{convertName(optionsParam.name)}
		@end{}):\n

		@if{method.comment != null && helper.removeTags(method.comment).length() > 0}
			@{helper.indentString("\"\"\"\n" + helper.removeTags(method.comment) + "\"\"\"\n", ind + "    ")}
		@else{}
			@{ind}    """"""\n
		@end{}

		@if{childMethods.isEmpty()}
			@comment{"Import the Python return type inside of the method if its not "}
			@comment{"already imported. Needed to avoid circular imports."}
			@if{baseMethod.returnType.kind == CLASS_API && 
               !imported.contains(baseMethod.returnType.raw.simpleName) && 
               baseMethod.returnType.raw.simpleName != ifaceSimpleName}
				@code{retType = baseMethod.returnType}
				@code{refedType = retType.raw.name}
				@code{refedPackage = refedType.substring(refedType.lastIndexOf('.', refedType.lastIndexOf('.') - 1) + 1, 
                                                         refedType.lastIndexOf('.'))}
				@{ind}    from @{retType.moduleName}_python.@{refedPackage}.@{convertName(retType.simpleName)} import @{retType.simpleName}\n
				@code{imported.add(retType.simpleName)}
			@end{}
			@if{requiresTypeCheck([baseMethod])}
				@{ind}    if @includeNamed{'genCondition';method=baseMethod;}:\n
				@if{baseMethod.fluent}
					@{ind}        @includeNamed{'genMethodCall'; method=baseMethod}\n
				@else{}
					@{ind}        return @includeNamed{'convReturn'; templ='genMethodCall'; returnType=baseMethod.returnType; method=baseMethod}\n
				@end{}
				@{ind}    else:\n
				@{ind}        raise TypeError("Invalid arguments for @{convertName(methodName)}")\n
			@else{}
				@if{baseMethod.fluent}
					@{ind}    @includeNamed{'genMethodCall'; method=baseMethod}\n
				@else{}
					@{ind}    return @includeNamed{'convReturn'; templ='genMethodCall'; returnType=baseMethod.returnType; method=baseMethod}\n
				@end{}
			@end{}
		@else{}
			@code{mcnt = 0;}
			@foreach{method: childMethods}
				@{ind}    @if{mcnt == 0}if @code{mcnt++}@else{}elif @end{}@includeNamed{'genCondition'}:\n
				@if{method.fluent}
					@{ind}        @includeNamed{'genMethodCall'}\n
				@else{}
					@{ind}        return @includeNamed{'convReturn'; templ='genMethodCall'; returnType=method.returnType}\n
				@end{}
			@end{}
			@if{requiresTypeCheck([baseMethod])}
				@{ind}    elif @includeNamed{'genCondition';method=baseMethod;}:\n
				@if{baseMethod.fluent}
					@{ind}        @includeNamed{'genMethodCall'; method=baseMethod}\n
				@else{}
					@{ind}        return @includeNamed{'convReturn'; templ='genMethodCall'; returnType=baseMethod.returnType; method=baseMethod}\n
				@end{}
				@{ind}    else:\n
				@{ind}        raise TypeError("Invalid arguments for @{convertName(methodName)}")\n
			@else{}
				@{ind}    else:\n
				@if{baseMethod.fluent}
					@{ind}        @includeNamed{'genMethodCall'; method=baseMethod}\n
				@else{}
					@{ind}        return @includeNamed{'convReturn'; templ='genMethodCall'; returnType=baseMethod.returnType; method=baseMethod}\n
				@end{}
			@end{}
			@if{baseMethod.fluent}
				        return @if{static}@{ifaceSimpleName}@else{}self@end{}\n
			@end{}
		@end{}
		\n
	@end{}
@end{}

@comment{"Generate a Vert.x handler"}
@comment{"========================="}

@code{handlers = []}

@declare{'genHandlers'}
	@code{methodList = methodsByName.get(methodName); overloaded = methodList.size() > 1; method = methodList.get(0);}
	@foreach{method: methodList}
		@foreach{param: method.params}
			@if{param.type.kind == CLASS_HANDLER && !handlers.contains(param.type.name)}
				@if{param.type.args[0].kind == CLASS_ASYNC_RESULT}
					@if{param.type.args[0].args[0].raw != null}
						@code{className = 'Async' + param.type.args[0].args[0].raw.simpleName + 'Handler'}
					@else{}
						@code{className = 'Async' + param.type.args[0].args[0].name + 'Handler'}
					@end{}
				@else{}
					@if{param.type.args[0].raw != null}
						@code{className = param.type.args[0].raw.simpleName + 'Handler'}
					@else{}
						@code{className = param.type.args[0].name + 'Handler'}
					@end{}
				@end{}
				class @{className}(object):\n
				    class Java:\n
				        implements = ['io.vertx.core.Handler']\n
				    def __init__(self, handler):\n
				        self.handler = handler\n
				    def handle(self, result):\n
				        try:\n
					@if{param.type.args[0].kind == CLASS_ASYNC_RESULT}
				            if result.succeeded():\n
						@if{param.type.args[0].args[0].name.startsWith('java.lang.Void')}
				                self.handler(None, None)\n
						@else{}
				                self.handler(@includeNamed{'convReturn'; templ='arVal'; returnType=param.type.args[0].args[0]}, None)\n
						@end{}
				            else:\n
				                self.handler(None, result.cause())\n
					@else{}
						@if{param.type.args[0].name.startsWith('java.lang.Void')}
				            self.handler(None)\n
						@else{}
				            self.handler(@includeNamed{'convReturn'; templ='resultVal'; returnType=param.type.args[0]})\n
						@end{}
					@end{}
				        except Exception:\n
				            import traceback\n
				            traceback.print_exc()\n
				            raise\n
				
				\n
				@code{handlers.add(param.type.name)}
			@end{}
		@end{}
	@end{}
@end{}

@comment{"This is where the generation starts"}
@comment{"==================================="}

# Copyright 2014 the original author or authors.\n
#\n
# Licensed under the Apache License, Version 2.0 (the "License");\n
# you may not use this file except in compliance with the License.\n
# You may obtain a copy of the License at\n
#\n
#      http://www.apache.org/licenses/LICENSE-2.0\n
#\n
# Unless required by applicable law or agreed to in writing, software\n
# distributed under the License is distributed on an "AS IS" BASIS,\n
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n
# See the License for the specific language governing permissions and\n
# limitations under the License.\n

@comment{"Import utility functions into all modules"}

from __future__ import unicode_literals, print_function, absolute_import\n
from vertx_python import util\n
from vertx_python.compat import long, basestring\n
\n

@comment{"Initalize the Vert.x client if necessary"}

util.vertx_init()\n
\n


@code{imported = []}
@foreach{referencedType : referencedTypes}
	@if{!imported.contains(referencedType.simpleName)}
		@code{refedType = referencedType.raw.name}
		@code{refedPackage = refedType.substring(refedType.lastIndexOf('.', refedType.lastIndexOf('.') - 1) + 1, refedType.lastIndexOf('.'))}
		from @{referencedType.moduleName}_python.@{refedPackage}.@{convertName(referencedType.simpleName)} import @{referencedType.simpleName}\n
		@code{imported.add(referencedType.simpleName)}
	@end{}
@end{}
\n

@comment{"The top level vars for the module"}

@code{referencedDoTypes = []}
@foreach{dataObjectType: referencedDataObjectTypes}
	@if{!referencedDoTypes.contains(dataObjectType)}
		@{dataObjectType.simpleName} = util.jvm.@{dataObjectType}\n
		@code{referencedDoTypes.add(dataObjectType)}
	@end{}
@end{}
\n
@code{ifaceName = helper.decapitaliseFirstLetter(ifaceSimpleName)}

@comment{"The class"}
class @{ifaceSimpleName}(@foreach{superType: superTypes}@{superType.raw.simpleName}@end{", "}@if{!superTypes.isEmpty()}, object@else{}object@end{}):\n

@comment{"The main comment"}
@if{ifaceComment != null}
	@{helper.indentString("\"\"\"\n" + helper.removeTags(ifaceComment) + "\n\"\"\"\n", "    ")}
@end{}

@comment{"The constructor"}
    def __init__(self, jval):\n
        self.j@{ifaceName} = jval\n
		@foreach{superType: superTypes}
	        @{superType.raw.simpleName}.__init__(self, jval)\n
		@end{}
\n

@comment{"Now iterate through each unique method"}

@foreach{methodName:methodsByName.keySet()}
	@comment{"Call out to actually generate the method, considering only non-static ones"}
	@includeNamed{'genMethod';static=false;ind="    "}
@end{}

@comment{"Each object has a _jdel property which gives access to the underlying Java object"}
    @@property\n
    def _jdel(self):\n
        return self.j@{ifaceName}\n\n

@comment{"Iterate through the methods again, this time only considering the static ones"}

@foreach{methodName:methodsByName.keySet()}
	@comment{"Call out to generate the static method"}
	@includeNamed{'genMethod';static=true;ind="    "}
@end{}

@comment{"Iterate through methods again and create result handler classes"}

@foreach{methodName:methodsByName.keySet()}
	@includeNamed{'genHandlers'}
@end{}
